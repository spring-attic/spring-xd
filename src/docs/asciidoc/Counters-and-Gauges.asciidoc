
// Empty line above needed after the list from previous file
[[counters-and-gauges]]
== Counters and Gauges
Counter and Gauges are analytical data structures collectively referred to as metrics.  Metrics can be used directly in place of a sink just as if you were creating any other xref:Streams#streams[stream], but you can also analyze data from an existing stream using a xref:Taps#taps[tap]. We'll look at some examples of using metrics with taps in the following sections. As a prerequisite start the XD Container as instructed in the xref:Getting-Started#getting-started[Getting Started] page. 

The following types of metrics are available

* <<counter,Counter>>
* <<field-value-counter,Field Value Counter>>
* <<aggregate-counter, Aggregate Counter>>
* <<gauge,Gauge>>
* <<rich-gauge,Rich Gauge>>

Spring XD supports these metrics and analytical data structures as a general purpose class library that works with several backend storage technologies.  The 1.0 release provides in memory and Redis implementations.

[TIP]
====
As of _Spring XD 1.2_ you can now create data visualizations for the various counters and gauges using the _Admin UI_. Please see the <<adminui-analytics, Admin UI Analytics Chapter>> for more details.
====

[[counter]]
=== Counter

A counter is a Metric that associates a unique name with a long value. It is primarily used for counting events triggered by incoming messages on a target stream. You create a counter with a unique name and optionally an initial value then set its value in response to incoming messages. The most straightforward use for counter is simply to count messages coming into the target stream. That is, its value is incremented on every message. This is exactly what the _counter_ module provided by Spring XD does. 

Here's an example:

Start by creating a data ingestion stream. Something like:

   xd:> stream create --name springtweets --definition "twittersearch --consumerKey=<your_key> --consumerSecret=<your_secret> --query=spring | file --dir=/tweets/" --deploy

Next, create a tap on the _springtweets_ stream that sets a message counter named _tweetcount_

   xd:> stream create --name tweettap --definition "tap:stream:springtweets > counter --name=tweetcount" --deploy

To retrieve the count:

[source,bash]
----
xd:>counter display tweetcount
----

//^sink.counter
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$sink.counter' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$counter$$** $$sink$$ has the following options:

$$name$$:: $$the name of the metric to contribute to (will be created if necessary)$$ *($$String$$, default: `<stream name>`)*
$$nameExpression$$:: $$a SpEL expression to compute the name of the metric to contribute to$$ *($$String$$, no default)*
//$sink.counter

[[field-value-counter]]
=== Field Value Counter (`field-value-counter`)

A field value counter is a Metric used for counting occurrences of unique values for a named field in a message payload. XD Supports the following payload types out of the box:

* POJO (Java bean)
* Tuple
* JSON String

For example suppose a message source produces a payload with a field named _user_ :

[source,java]
class Foo {
   String user;
   public Foo(String user) {
       this.user = user;
   }
}

If the stream source produces messages with the following objects:

[source, java]
   new Foo("fred")
   new Foo("sue")
   new Foo("dave")
   new Foo("sue")

The field value counter on the field _user_ will contain:

    fred:1, sue:2, dave:1 

Multi-value fields are also supported. For example, if a field contains a list, each value will be counted once:
    
     users:["dave","fred","sue"]
     users:["sue","jon"]

The field value counter on the field _users_ will contain:

    dave:1, fred:1, sue:2, jon:1

//^sink.field-value-counter
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$sink.field-value-counter' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$field-value-counter$$** $$sink$$ has the following options:

$$fieldName$$:: $$the name of the field for which values are counted$$ *($$String$$, no default)*
$$name$$:: $$the name of the metric to contribute to (will be created if necessary)$$ *($$String$$, default: `<stream name>`)*
$$nameExpression$$:: $$a SpEL expression to compute the name of the metric to contribute to$$ *($$String$$, no default)*
//$sink.field-value-counter

To try this out, create a stream to ingest twitter feeds containing the word _spring_ and output to a file:

   xd:> stream create --name springtweets --definition "twittersearch --consumerKey=<your_key> --consumerSecret=<your_secret> --query=spring | file" --deploy

Now create a tap for a field value counter:

   xd:> stream create --name fromUserCount --definition "tap:stream:springtweets > field-value-counter --fieldName=user.screen_name" --deploy

The _twittersearch_ source produces JSON strings which contain the user id of the tweeter in the _fromUser_ field. The _field_value_counter_ sink parses the tweet and updates a field value counter named _fromUserCount_ in Redis. To view the counts:

[source,bash]
----
From xd-shell,
  xd:> field-value-counter display fromUserCount
----

[[aggregate-counter]]
=== Aggregate Counter (`aggregate-counter`)

The aggregate counter differs from a simple counter in that it not only keeps a total value for the count, but also retains the total count values for each minute, hour day and month of the period for which it is run. The data can then be queried by supplying a start and end date and the resolution at which the data should be returned. 

Creating an aggregate counter is very similar to a simple counter. For example, to obtain an aggregate count for our spring tweets stream:
   
    xd:> stream create --name springtweets --definition "twittersearch --query=spring | file" --deploy

you'd simply create a tap which pipes the input to `aggregate-counter`:

   xd:> stream create --name tweettap --definition "tap:stream:springtweets > aggregate-counter --name=tweetcount" --deploy

From the XD shell:
   
   xd:> aggregate-counter display tweettap

Note: you can also use some criteria to filter out aggregate counter display values. Please refer to Shell documentation for aggregate counter for more details.
 

//^sink.aggregate-counter
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$sink.aggregate-counter' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$aggregate-counter$$** $$sink$$ has the following options:

$$dateFormat$$:: $$a pattern (as in SimpleDateFormat) for parsing/formatting dates and timestamps$$ *($$String$$, default: `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`)*
$$incrementExpression$$:: $$how much to increment each bucket, as a SpEL against the message$$ *($$String$$, default: `1`)*
$$name$$:: $$the name of the metric to contribute to (will be created if necessary)$$ *($$String$$, default: `<stream name>`)*
$$nameExpression$$:: $$a SpEL expression to compute the name of the metric to contribute to$$ *($$String$$, no default)*
$$timeField$$:: $$name of a field in the message that contains the timestamp to contribute to$$ *($$String$$, default: `null`)*
//$sink.aggregate-counter

[[gauge]]
=== Gauge

A gauge is a Metric, similar to a counter in that it holds a single long value associated with a unique name. In this case the value can represent any numeric value defined by the application. 

The _gauge_ sink provided with XD stores expects a numeric value as a payload, typically this would be a decimal formatted string.

//^sink.gauge
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$sink.gauge' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$gauge$$** $$sink$$ has the following options:

$$name$$:: $$the name of the metric to contribute to (will be created if necessary)$$ *($$String$$, default: `<stream name>`)*
$$nameExpression$$:: $$a SpEL expression to compute the name of the metric to contribute to$$ *($$String$$, no default)*
//$sink.gauge

Here is an example of creating a tap for a gauge:

[[simple-tap-example]]
==== Simple Tap Example

Create an ingest stream

    xd:> stream create --name test --definition "http --port=9090 | file" --deploy

Next create the tap:

    xd:> stream create --name simplegauge --definition "tap:stream:test > gauge" --deploy

Now Post a message to the ingest stream:

    xd:> http post --target http://localhost:9090 --data "10"

Check the gauge:

[source,bash]
----
xd:>gauge display --name simplegauge
----

[[rich-gauge]]
=== Rich Gauge (`rich-gauge`)

A rich gauge is a Metric that holds a double value associated with a unique name. In addition to the value, the rich gauge keeps a running average, along with the minimum and maximum values and the sample count.

The _rich-gauge_ sink provided with XD expects a numeric value as a payload, typically this would be a decimal formatted string, and keeps its value in a store.

//^sink.rich-gauge
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$sink.rich-gauge' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$rich-gauge$$** $$sink$$ has the following options:

$$alpha$$:: $$smoothing constant, or -1 to use arithmetic mean$$ *($$double$$, default: `-1.0`)*
$$name$$:: $$the name of the metric to contribute to (will be created if necessary)$$ *($$String$$, default: `<stream name>`)*
$$nameExpression$$:: $$a SpEL expression to compute the name of the metric to contribute to$$ *($$String$$, no default)*
//$sink.rich-gauge

NOTE: The smoothing factor behaves as an https://en.wikipedia.org/wiki/Exponential_smoothing[exponential moving average]. The default value does no smoothing.

Here are some examples of creating a tap for a rich gauge:

==== Simple Tap Example

Create an ingest stream

      xd:> stream create --name test --definition "http --port=9090 | file" --deploy

Next create the tap:

      xd:> stream create --name testgauge --definition "tap:stream:test > rich-gauge" --deploy

Now Post some messages to the ingest stream:

    xd:> http post --target http://localhost:9090 --data "10"
    xd:> http post --target http://localhost:9090 --data "13"
    xd:> http post --target http://localhost:9090 --data "16"

Check the gauge:

[source,bash]
----
xd:>rich-gauge display testgauge
----

==== Stock Price Example

In this example, we will track stock prices, which is a more practical example. The data is ingested as JSON strings like 

    {"symbol":"VMW","price":72.04}


Create an ingest stream

     xd:> stream create --name stocks --definition "http --port=9090 | file"

Next create the tap, using the transform module to extract the stock price from the payload: 

     xd:> stream create --name stockprice --definition "tap:stream:stocks > transform --expression=#jsonPath(payload,'$.price') | rich-gauge"

Now Post some messages to the ingest stream:

    xd:> http post --target http://localhost:9090 --data {"symbol":"VMW","price":72.04}
    xd:> http post --target http://localhost:9090 --data {"symbol":"VMW","price":72.06}
    xd:> http post --target http://localhost:9090 --data {"symbol":"VMW","price":72.08}

Note: JSON fields should be separated by a comma without any spaces. Alternatively, enclose the whole argument to `--data` with quotes and escape inner quotes with a backslash.

Check the gauge:

[source,bash]
----
xd:>rich-gauge display stockprice
----

==== Improved Stock Price Example

In this example, we will track stock prices for selected stocks. The data is ingested as JSON strings like 

    {"symbol":"VMW","price":72.04}
    {"symbol":"EMC","price":24.92}

The previous example would feed these prices to a single gauge. What we really want is to create a separate tap for each ticker symbol in which we are interested:

Create an ingest stream

     xd:> stream create --name stocks --definition "http --port=9090 | file"

Next create the tap, using the transform module to extract the stock price from the payload: 

     xd:> stream create --name vmwprice --definition "tap:stream:stocks > filter --expression=#jsonPath(payload,'$.symbol')==VMW | transform --expression=#jsonPath(payload,'$.price') | rich-gauge" --deploy
     xd:> stream create --name emcprice --definition "tap:stream:stocks > filter --expression=#jsonPath(payload,'$.symbol')==EMC | transform --expression=#jsonPath(payload,'$.price') | rich-gauge" --deploy

Now Post some messages to the ingest stream:

    xd:> http post --target http://localhost:9090 --data {"symbol":"VMW","price":72.04}
    xd:> http post --target http://localhost:9090 --data {"symbol":"VMW","price":72.06}
    xd:> http post --target http://localhost:9090 --data {"symbol":"VMW","price":72.08}

    xd:> http post --target http://localhost:9090 --data {"symbol":"EMC","price":24.92}
    xd:> http post --target http://localhost:9090 --data {"symbol":"EMC","price":24.90}
    xd:> http post --target http://localhost:9090 --data {"symbol":"EMC","price":24.96}

Check the gauge:

[source,bash]
----
xd:>rich-gauge display emcprice
xd:>rich-gauge display vmwprice
----

=== Accessing Analytics Data over the RESTful API

Spring XD has a discoverable RESTful API based on the Spring HATEAOS library.  You can discover the resources available by making a GET request on the root resource of the Admin server.  Here is an example where navigate down to find the data for a counter named 'httptap' that was created by these commands


[source,bash]
----
xd:>stream create --name httpStream --definition "http | file" --deploy
xd:>stream create --name httptap --definition "tap:stream:httpStream > counter" --deploy
xd:>http post --target http://localhost:9000 --data "helloworld"
----

The root resource returns 
[source,bash]
----
xd:>! wget  -q -S -O - http://localhost:9393/
{
  "links":[
    {},
    {
      "rel":"jobs",
      "href":"http://localhost:9393/jobs"
    },
    {
      "rel":"modules",
      "href":"http://localhost:9393/modules"
    },
    {
      "rel":"runtime/modules",
      "href":"http://localhost:9393/runtime/modules"
    },
    {
      "rel":"runtime/containers",
      "href":"http://localhost:9393/runtime/containers"
    },
    {
      "rel":"counters",
      "href":"http://localhost:9393/metrics/counters"
    },
    {
      "rel":"field-value-counters",
      "href":"http://localhost:9393/metrics/field-value-counters"
    },
    {
      "rel":"aggregate-counters",
      "href":"http://localhost:9393/metrics/aggregate-counters"
    },
    {
      "rel":"gauges",
      "href":"http://localhost:9393/metrics/gauges"
    },
    {
      "rel":"rich-gauges",
      "href":"http://localhost:9393/metrics/rich-gauges"
    }
  ]
}
----

Following the resource location for the counter

[source,bash]
----
xd:>! wget  -q -S -O - http://localhost:9393/metrics/counters
{
  "links":[

  ],
  "content":[
    {
      "links":[
        {
          "rel":"self",
          "href":"http://localhost:9393/metrics/counters/httptap"
        }
      ],
      "name":"httptap"
    }
  ],
  "page":{
    "size":0,
    "totalElements":1,
    "totalPages":1,
    "number":0
  }
}
----

And then the data for the counter itself
[source,bash]
----
xd:>! wget  -q -S -O - http://localhost:9393/metrics/counters/httptap
{
  "links":[
    {
      "rel":"self",
      "href":"http://localhost:9393/metrics/counters/httptap"
    }
  ],
  "name":"httptap",
  "value":2
}
----

