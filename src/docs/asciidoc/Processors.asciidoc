
// Empty line above needed after the list from previous file
[[processors]]
== Processors

This section describes the _processor_ modules included with Spring XD. A processor implements a processing task within a stream. A stream may chain multiple processors sequentially as needed.  To run the examples shown here, start the XD Container as instructed in the
xref:Getting-Started#getting-started[Getting Started] page.

The available Processors are

* <<aggregator, Aggregator>>
* <<filter, Filter>>
* <<header-enricher, Header Enricher>>
* <<http-clent, HTTP Client>>
* <<json-to-tuple, JSON to Tuple>>
* <<object-to-json, Object to JSON>>
* <<script, Script>>
* <<shell, Shell Command>>
* <<splitter, Splitter>>
* <<transform, Transform>>

See the section xref:Creating-a-Processor-Module#creating-a-processor-module[Creating a Processor Module] for information on how to create custom processor modules.

[[aggregator]]
=== Aggregator
The aggregator module does the opposite of the splitter, and builds upon the concept of the same name found in Spring Integration. By default, it will consider all incoming messages from a stream to belong to the same group:

  xd:> stream create --name aggregates --definition "http | aggregator --count=3 --aggregation=T(org.springframework.util.StringUtils).collectionToDelimitedString(#this.![payload],' ') | log" --deploy

This uses a SpEL expression that will basically concatenate all payloads together, inserting a space character in between. As such,

  xd:> http post --data Hello
  xd:> http post --data World
  xd:> http post --data !

would emit a single message whose contents is "Hello World !". This is because we set the aggregator release strategy to accumulate 3 messages.

//^processor.aggregator
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.aggregator' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$aggregator$$** $$processor$$ has the following options:

$$aggregation$$:: $$how to construct the aggregated message (SpEL expression against a collection of messages)$$ *($$String$$, default: `#this.![payload]`)*
$$correlation$$:: $$how to correlate messages (SpEL expression against each message)$$ *($$String$$, default: `'<stream name>'`)*
$$count$$:: $$the number of messages to group together before emitting a group$$ *($$int$$, default: `50`)*
$$dbkind$$:: $$which flavor of init scripts to use for the jdbc store (blank to attempt autodetection)$$ *($$String$$, no default)*
$$driverClassName$$:: $$the jdbc driver to use when using the jdbc store$$ *($$String$$, no default)*
$$hostname$$:: $$hostname of the redis instance to use as a store$$ *($$String$$, default: `localhost`)*
$$initializeDatabase$$:: $$whether to auto-create the database tables for the jdbc store$$ *($$boolean$$, default: `false`)*
$$password$$:: $$the password to use when using the jdbc or redis store$$ *($$String$$, default: ``)*
$$port$$:: $$port of the redis instance to use as a store$$ *($$int$$, default: `6379`)*
$$release$$:: $$when to release messages (SpEL expression against a collection of messages accumulated so far)$$ *($$String$$, no default)*
$$store$$:: $$the kind of store to use to retain messages$$ *($$StoreKind$$, default: `memory`, possible values: `memory,jdbc,redis`)*
$$timeout$$:: $$the delay (ms) after which messages should be released, even if the completion criteria is not met$$ *($$int$$, default: `50000`)*
$$url$$:: $$the jdbc url to connect to when using the jdbc store$$ *($$String$$, no default)*
$$username$$:: $$the username to use when using the jdbc store$$ *($$String$$, no default)*
//$processor.aggregator

[NOTE]
====
* Some of the options are only relevant when using a particular `store`
* The default `correlation` of `'<stream name>'` actually considers all messages to be correlated, since they all belong to the same stream.
* Using the `release` option overrides the `count` option (which is a simpler approach)
* The default for `aggregation` creates a new collection made of the payloads of the accumulated messages
* About the `timeout` option: due to the way it is implemented (see MessageGroupStoreReaper in the Spring Integration documentation), the actual observed delay may vary between `timeout` and `2xtimeout`.
====

[[filter]]
=== Filter
Use the filter module in a xref:Streams#streams[stream] to determine whether a Message should be passed to the output channel.

//^processor.filter
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.filter' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$filter$$** $$processor$$ has the following options:

$$expression$$:: $$a SpEL expression used to transform messages$$ *($$String$$, default: `payload.toString()`)*
$$propertiesLocation$$:: $$the path of a properties file containing custom script variable bindings$$ *($$String$$, no default)*
$$refreshDelay$$:: $$how often to check (in milliseconds) whether the script has changed; -1 for never$$ *($$long$$, default: `60000`)*
$$script$$:: $$reference to a script used to process messages$$ *($$String$$, no default)*
$$variables$$:: $$variable bindings as a comma delimited string of name-value pairs, e.g., 'foo=bar,baz=car'$$ *($$String$$, no default)*
//$processor.filter

==== Filter with SpEL expression
The simplest way to use the filter processor is to pass a SpEL expression when creating the stream. The expression should evaluate the message and return true or false.  For example:

    xd:> stream create --name filtertest --definition "http | filter --expression=payload=='good' | log" --deploy

This filter will only pass Messages to the log sink if the payload is the word "good". Try sending "good" to the HTTP endpoint and you should see it in the XD log:

    xd:> http post --target http://localhost:9000 --data "good"

Alternatively, if you send the word "bad" (or anything else), you shouldn't see the log entry.

==== Filter using jsonPath evaluation

As part of the SpEL expression you can make use of the pre-registered JSON Path function.

This filter example shows to pass messages to the output channel if they contain a specific JSON field matching a specific value.

    xd:> stream create --name jsonfiltertest --definition "http --port=9002 | filter --expression=#jsonPath(payload,'$.firstName').contains('John') | log" --deploy

*Note:* There is no space between payload JSON and the jsonPath in the expression

This filter will only pass Messages to the log sink if the JSON payload contains the _firstName_ "John". Try sending this payload to the HTTP endpoint and you should see it in the XD log:

    xd:> http post --target http://localhost:9002 --data "{\"firstName\":\"John\", \"lastName\":\"Smith\"}"

Alternatively, if you send a different _firstName_, you shouldn't see the log entry.

Here is another example usage of filter

    filter --expression=#jsonPath(payload,'$.entities.hashtags[*].text').contains('obama')

This is an example that is operating on a JSON payload of tweets as consumed from the twitter search module.

==== Filter with Groovy Script
For more complex filtering, you can pass the location of a Groovy script using the _script_ option. If you want to pass variable values to your script, you can statically bind values using the _variables_ option or optionally pass the path to a properties file containing the bindings using the _propertiesLocation_ option.All properties in the file will be made available to the script as variables. Note that _payload_ and _headers_ are implicitly bound to give you access to the data contained in a message.


Example:

NOTE: These features are common to all modules backed by Groovy scripts.

[source,groovy]
----
//custom-filter.groovy
return payload.size()> 4 || shortstrings=='true'
----

----
#custom-filter.properties
shortstrings=false
----

By default, Spring XD will search the classpath for _custom-filter.groovy_ and _custom-filter.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _script_ and _properties-location_ values with _file:_ to load from the file system.

In the following stream definitions, the filter will pass only the first message:

----
xd>: stream create --name groovyfiltertest1 --definition "http --port=9001 | filter --script=file:<absolute-path-to>/custom-filter.groovy --variables='shortstrings=false' | log" --deploy
Created and deployed new stream 'groovyfiltertest1'
xd:>http post --target http://localhost:9001 --data hello
xd:http post --target http://localhost:9001 --data hi
----

----
xd>: stream create --name groovyfiltertest2 --definition "http --port=9002 | filter --script=file:<absolute-path-to>/custom-filter.groovy --propertiesLocation=file:<absolute-path-to>/custom-filter.properties | log" --deploy
Created and deployed new stream 'groovyfiltertest2'
xd:>http post --target http://localhost:9002 --data hello
xd:http post --target http://localhost:9002 --data hi
----

In the following stream definitions, the filter will pass all messages (provided the payload type supports a size() method):

----
xd>: stream create --name groovyfiltertest1 --definition "http --port=9001 | filter --script=file:<absolute-path-to>/custom-filter.groovy --variables='shortstrings=false' | log" --deploy
Created and deployed new stream 'groovyfiltertest1'
----

----
xd>: stream create --name groovyfiltertest2 --definition "http --port=9002 | filter --script=file:<absolute-path-to>/custom-filter.groovy --variables='shortstring=false' --propertiesLocation=file:<absolute-path-to>/custom-filter.properties | log" --deploy
Created and deployed new stream 'groovyfiltertest2'
----

Note the last example demonstrates that values specified in _variables_ override values from _propertiesLocation_

TIP: The script file's modified timestamp is checked for changes every 60 seconds by default; this can be changed with
the `refreshDelay` deployment property: `--refreshDelay=30000` (every 30 seconds or 30,000ms), `--refreshDelay=-1` to
disable refresh.

[[header-enricher]]
=== Header Enricher (`header-enricher`)
The `header-enricher` processor provides a basic header enricher to allow a stream to add runtime state in one or more message headers. Message headers are preserved across the entire stream flow and may be referenced by down stream modules using SpEL, e.g., `expression=headers['foo']`.

Header expressions are provided using the `headers` module option which expects a JSON string.

Some Examples:

A Simple SpEL expression

----
xd:>stream create t1 --definition "http | header-enricher --headers={\"foo\":\"payload.toUpperCase()\"} | log --expression=headers" --deploy
xd:>http post --data hello --target http://localhost:9000
----

You should see the message headers, including **foo=HELLO** in the container console log:

----
2015-05-24T11:40:40-0400 1.2.0.SNAP INFO pool-12-thread-4 sink.t1 - {requestMethod=POST, foo=HELLO, User-Agent=Java/1.8.0_25, Host=localhost:9000, id=f6b2c420-cd12-2d5e-e0cb-675f60fb9a63, Content-Length=5, contentType=text/plain;Charset=UTF-8, requestPath=/, timestamp=1432482040939}
----

Multiple Headers: This will add 2 headers, **foo** and **bar**

----
xd:> stream create t2 --definition "http | header-enricher --headers={\"foo\":\"payload.toUpperCase()\",\"bar\":\"payload+',world'\"} | log --expression=headers" --deploy
xd:>http post --data hello --target http://localhost:9000
----

The result:

----
2015-05-24T11:49:19-0400 1.2.0.SNAP INFO pool-27-thread-4 sink.t2 - {bar=hello,world, requestMethod=POST, foo=HELLO, User-Agent=Java/1.8.0_25, Host=localhost:9000, id=c9220992-f71c-db3f-0f22-b5ab262d4aee, Content-Length=5, contentType=text/plain;Charset=UTF-8, requestPath=/, timestamp=1432482559740}
----

JSON Path expressions: This example uses a JSON Path expression to extract a field value in a JSON Payload:

----
xd:>stream create t3 --definition "http | header-enricher --headers={\"foo\":\"#jsonPath(payload,'$.duration')\"} | log --expression=headers" --deploy
xd:>http post --data {"duration":123.45} --target http://localhost:9000
----

**foo=123.45** !!

----
2015-05-24T11:45:16-0400 1.2.0.SNAP INFO pool-23-thread-4 sink.t3 - {requestMethod=POST, foo=123.45, User-Agent=Java/1.8.0_25, Host=localhost:9000, id=87d229b9-a434-31c2-eb35-b42ca3f8352a, Content-Length=19, contentType=text/plain;Charset=UTF-8, requestPath=/, timestamp=1432482316080}
----

Literal Strings with Embedded Spaces: SpEL expects literals to be enclosed in single quotes. This is straight forward when the literal does not contain embedded spaces as in the `Multple Headers` example above. Using embedded spaces requires either
wrapping the `headers` value in single quotes and escaping the single quote for the literal string

----
xd:>stream create t4 --definition "http | header-enricher --headers='{\"foo\":\"''this is a literal string''\"}' | log --expression=headers" --deploy
----

or you can encode embedded spaces using the Unicode escape sequence (the leading '\' must itself be escaped):

----
xd:>stream create t4 --definition "http | header-enricher --headers={\"foo\":\"'this\\u0020is\\u0020a\\u0020literal\\u0020string'\"} | log --expression=headers" --deploy
----

the result:

----
2015-05-24T12:26:32-0400 1.2.0.SNAP INFO pool-31-thread-4 sink.t4 - {requestMethod=POST, foo=this is a literal string, User-Agent=Java/1.8.0_25, Host=localhost:9000, id=b8892a1b-57b1-de6e-71de-e30f84cd199a, Content-Length=5, contentType=text/plain;Charset=UTF-8, requestPath=/, timestamp=1432484792949}
----

//^processor.header-enricher
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.header-enricher' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$header-enricher$$** $$processor$$ has the following options:

$$headers$$:: $$a JSON document representing headers in which values are SpEL expressions, e.g {"h1":"exp1","h2":"exp2"}$$ *($$String$$, no default)*
$$overwrite$$:: $$set to true to overwrite any existing message headers$$ *($$Boolean$$, default: `false`)*
//$processor.header-enricher

[[http-client]]
=== HTTP Client (`http-client`)
The `http-client` processor acts as a client that issues HTTP requests to a remote server, submitting the message payload it receices to that server and in turn emitting the response it receives to the next module down the line.

For example, the following command will result in an immediate fetching of earthquake data and it being logged in the container:
----
xd:>stream create earthquakes --definition "trigger | http-client --url='''https://earthquake.usgs.gov/earthquakes/feed/geojson/all/day''' --httpMethod=GET | log" --deploy
----

[NOTE]
====
Please be aware that the `url` option above is actually a SpEL expression, hence the triple quotes. If you'd like to learn more about quotes, please read xref:DSL-Reference#dsl-quotes-escaping[the relevant documentation].
====

//^processor.http-client
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.http-client' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$http-client$$** $$processor$$ has the following options:

$$charset$$:: $$the charset to use when in the Content-Type header when emitting Strings$$ *($$String$$, default: `UTF-8`)*
$$httpMethod$$:: $$the http method to use when performing the request$$ *($$HttpMethod$$, default: `POST`, possible values: `OPTIONS,GET,HEAD,POST,PUT,PATCH,DELETE,TRACE,CONNECT`)*
$$mappedRequestHeaders$$:: $$request message header names to be propagated to/from the adpater/gateway$$ *($$String$$, default: `HTTP_REQUEST_HEADERS`)*
$$mappedResponseHeaders$$:: $$response message header names to be propagated from the adpater/gateway$$ *($$String$$, default: `HTTP_RESPONSE_HEADERS`)*
$$replyTimeout$$:: $$the amount of time to wait (ms) for a response from the remote server$$ *($$int$$, default: `0`)*
$$url$$:: $$the url to perform an http request on$$ *($$String$$, no default)*
//$processor.http-client


[[json-to-tuple]]
=== JSON to Tuple (`json-to-tuple`)
The `json-to-tuple` processor is able to transform a String representation of some JSON map into a xref:Tuples#tuples[Tuple].

Here is a simple example:
----
xd:>stream create tuples --definition "http | json-to-tuple | transform --expression='payload.firstName + payload.lastName' | log" --deploy

xd:>http post --data '{"firstName": "Spring", "lastName": "XD"}'
----

[NOTE]
====
Transformation to Tuple can be used as an alternative to xref:Type-conversion#type-conversion[Type Conversion].
====

//^processor.json-to-tuple
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.json-to-tuple' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$json-to-tuple$$** $$processor$$ has no particular option (in addition to options shared by all modules)

//$processor.json-to-tuple

[[object-to-json]]
=== Object to JSON (`object-to-json`)
The `object-to-json` processor can be used to convert any java Object to a JSON String.

In the following example, notice how the collection of three elements is transformed to JSON (in particular, the three Strings are surrounded by quotes):

----
xd:>stream create json --deploy --definition "http | aggregator --count | object-to-json | log"

xd:>http post --data hello
xd:>http post --data world
xd:>http post --data !
----

results in `["hello", "world", "!"]` appearing in the log.

[NOTE]
====
Transformation to JSON can be used as an alternative to xref:Type-conversion#type-conversion[Type Conversion].
====

//^processor.object-to-json
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.object-to-json' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$object-to-json$$** $$processor$$ has no particular option (in addition to options shared by all modules)

//$processor.object-to-json

[[script]]
=== Script
The script processor contains a _Service Activator_ that invokes a specified Groovy script. This is a slightly more generic way to accomplish processing logic, as the provided script may simply terminate the stream as well as transform or filter Messages.

//^processor.script
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.script' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$script$$** $$processor$$ has the following options:

$$propertiesLocation$$:: $$the path of a properties file containing custom script variable bindings$$ *($$String$$, no default)*
$$refreshDelay$$:: $$how often to check (in milliseconds) whether the script has changed; -1 for never$$ *($$long$$, default: `60000`)*
$$script$$:: $$reference to a script used to process messages$$ *($$String$$, no default)*
$$variables$$:: $$variable bindings as a comma delimited string of name-value pairs, e.g., 'foo=bar,baz=car'$$ *($$String$$, no default)*
//$processor.script

To use the module, pass the location of a Groovy script using the _script_ attribute. If you want to pass variable values to your script, you can statically bind values using the _variables_ option or optionally pass the path to a properties file containing the bindings using the _propertiesLocation_ option. All properties in the file will be made available to the script as variables. Note that _payload_ and _headers_ are implicitly bound to give you access to the data contained in a message. See the <<filter, Filter>> example for a more detailed discussion of script variables.

----
xd:> stream create --name groovyprocessortest --definition "http --port=9006 | script --script=custom-processor.groovy --variables='x=foo' | log" --deploy
----

----
xd:> stream create --name groovyprocessortest --definition "http --port=9006 | script --script=custom-processor.groovy --propertiesLocation=custom-processor.properties | log" --deploy
----

By default, Spring XD will search the classpath for _custom-processor.groovy_ and _custom-processor.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _location_ and _properties-location_ values with _file:_ to load from the file system.

TIP: The script file's modified timestamp is checked for changes every 60 seconds by default; this can be changed with
the `refreshDelay` deployment property: `--refreshDelay=30000` (every 30 seconds or 30,000ms), `--refreshDelay=-1` to
disable refresh.

[[shell]]
=== Shell
The `shell` processor forks an external process by running a shell command to launch a process written in any language. The process should implement a continual loop that waits for input from `stdin` and writes a result to `stdout` in a request-response manner. The process will be destroyed when the stream is undeployed. For example, it is possible to invoke a Python script within a stream in this manner. Since the shell processor relies on low-level stream processing there are some additional requirements:

* Input and output data are expected to be Strings, the `charset` is configurable.
* The shell process must not write out of band data to `stdout`, such as a start up message or prompt.
* Anything written to `stderr` will be logged as an ERROR in Spring XD but will not terminate the stream.
* Responses written to `stdout` must be terminated using the configured encoder (CRLF or "\r\n" is the default) for the module and must not exceed the configured `bufferSize`
* Any external software required to run the script must be installed on the container node to which the module is deployed.

Here is a simple Python example that echos the input:

[source,python]
----
#echo.py
import sys

#=====================
# Write data to stdout
#=====================
def send(data):
  sys.stdout.write(data)
  sys.stdout.flush()

#===========================================
# Terminate a message using the default CRLF
#===========================================
def eod():
  send("\r\n")

#===========================
# Main - Echo the input
#===========================

while True:
  try:
    data = raw_input()
    if data:
      send(data)
      eod()
  except EOFError:
      eod()
      break
----

[NOTE]
====
Spring XD provides additional Python programming support for handling basic stream processing, as shown above, see xref:link:Creating-a-Python-Module[creating a Python module].
====

To try this example, copy the above script and save it to `echo.py`.  Start Spring XD and create a stream:

----
xd:>stream create pytest --definition "time | shell --command='python <absolute-path-to>/echo.py' | log" --deploy
Created and deployed new stream 'pytest'
----

you should see the time echoed in the log:

----
09:49:14,856  INFO task-scheduler-5 sink.pytest - 2014-10-10 09:49:14
09:49:15,860  INFO task-scheduler-1 sink.pytest - 2014-10-10 09:49:15
09:49:16,862  INFO task-scheduler-1 sink.pytest - 2014-10-10 09:49:16
09:49:17,864  INFO task-scheduler-1 sink.pytest - 2014-10-10 09:49:17
----

This script can be easily modified to do some actual work by providing a function that takes the input as an argument and returns a string. Then insert the function call:

[source,python]
----
while True:
  try:
    data = raw_input()
    if data:
      result = myfunc(data)
      send(result)
      eod()
  except EOFError:
      eod()
      break
----

//^processor.shell
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.shell' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$shell$$** $$processor$$ has the following options:

$$bufferSize$$:: $$the size of the buffer (bytes) to use when encoding/decoding$$ *($$int$$, default: `2048`)*
$$charset$$:: $$the charset used when converting from String to bytes$$ *($$String$$, default: `UTF-8`)*
$$command$$:: $$the shell command$$ *($$String$$, no default)*
$$encoder$$:: $$the encoder to use when sending messages$$ *($$Encoding$$, default: `CRLF`, possible values: `CRLF,LF,NULL,STXETX,RAW,L1,L2,L4`)*
$$environment$$:: $$additional process environment variables as comma delimited name-value pairs$$ *($$String$$, no default)*
$$redirectErrorStream$$:: $$redirects stderr to stdout$$ *($$boolean$$, default: `false`)*
$$workingDir$$:: $$the process working directory$$ *($$String$$, no default)*
//$processor.shell

[[splitter]]
=== Splitter
The splitter module builds upon the concept of the same name in Spring Integration and allows the splitting of a single message into several distinct messages.

//^processor.splitter
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.splitter' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$splitter$$** $$processor$$ has the following options:

$$expression$$:: $$a SpEL expression which would typically evaluate to an array or collection$$ *($$String$$, default: `payload`)*
//$processor.splitter

NOTE: The default value for `expression` is `payload`, which actually does not split, unless the message is already a collection.

As part of the SpEL expression you can make use of the pre-registered JSON Path function. The syntax is #jsonPath(payload,'<json path expression>')

==== Extract the value of a specific field

This splitter converts a JSON message payload to the value of a specific JSON field.

    xd:> stream create --name jsontransformtest --definition "http --port=9005 | splitter --expression=#jsonPath(payload,'$.firstName') | log" --deploy

Try sending this payload to the HTTP endpoint and you should see just the value "John" in the XD log:

    xd:> http post --target http://localhost:9005 --data '{"firstName":"John", "lastName":"Smith"}'

[[transform]]
=== Transform
Use the transform module in a xref:Streams#streams[stream] to convert a Message's content or structure.

//^processor.transform
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.transform' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$transform$$** $$processor$$ has the following options:

$$expression$$:: $$a SpEL expression used to transform messages$$ *($$String$$, default: `payload.toString()`)*
$$propertiesLocation$$:: $$the path of a properties file containing custom script variable bindings$$ *($$String$$, no default)*
$$refreshDelay$$:: $$how often to check (in milliseconds) whether the script has changed; -1 for never$$ *($$long$$, default: `60000`)*
$$script$$:: $$reference to a script used to process messages$$ *($$String$$, no default)*
$$variables$$:: $$variable bindings as a comma delimited string of name-value pairs, e.g., 'foo=bar,baz=car'$$ *($$String$$, no default)*
//$processor.transform

==== Transform with SpEL expression
The simplest way to use the transform processor is to pass a SpEL expression when creating the stream. The expression should return the modified message or payload.  For example:

    xd:> stream create --name transformtest --definition "http --port=9003 | transform --expression=payload.toUpperCase() | log" --deploy

This transform will convert all message payloads to upper case. If sending the word "foo" to the HTTP endpoint and you should see "FOO" in the XD log:

    xd:> http post --target http://localhost:9003 --data "foo"

As part of the SpEL expression you can make use of the pre-registered JSON Path function.  The syntax is #jsonPath(payload,'<json path expression>')

==== Transform with Groovy Script
For more complex transformations, you can pass the location of a Groovy script using the _script_ option. If you want to pass variable values to your script, you can statically bind values using the _variables_ option or optionally pass the path to a properties file containing the bindings using the _propertiesLocation_ option. All properties in the file will be made available to the script as variables. Note that _payload_ and _headers_ are implicitly bound to give you access to the data contained in a message. See the <<filter, Filter>> example for a more detailed discussion of script variables.

----
xd:> stream create --name groovytransformtest1 --definition "http --port=9004 | transform --script=custom-transform.groovy --variables="x=foo" | log" --deploy
----

----
xd:> stream create --name groovytransformtest2 --definition "http --port=9004 | transform --script=custom-transform.groovy --propertiesLocation=custom-transform.properties | log" --deploy
----

By default, Spring XD will search the classpath for _custom-transform.groovy_ and _custom-transform.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _script_ and _properties-location_ values with _file:_ to load from the file system.

TIP: The script file's modified timestamp is checked for changes every 60 seconds by default; this can be changed with
the `refreshDelay` deployment property: `--refreshDelay=30000` (every 30 seconds or 30,000ms), `--refreshDelay=-1` to
disable refresh.
